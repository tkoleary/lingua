// Generated by CoffeeScript 1.7.1

/* A Wintersmith tag plugin based on the built-in paginator plugin */
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

module.exports = function(env, callback) {

  /* Tag plugin. Defaults can be overridden in config.json
      e.g. "tag": {"perPage": 10}
   */
  var TagPaginatorPage, allTags, extend, extend2, getAllTags, getArticles, getArticlesByTag, getTagHome, getTagsFromArticle, options, paginatorDefaults, processTags, tagDefaults, tagHomePages;
  paginatorDefaults = {
    template: 'index.jade',
    articles: 'articles',
    first: 'index.html',
    filename: 'page/%d/index.html',
    perPage: 2
  };
  tagDefaults = {
    filename: 'tag/%s/%d/index.html'
  };
  extend2 = function(dest, src) {
    var key, value;
    for (key in src) {
      value = src[key];
      dest[key] = src[key];
    }
    return dest;
  };
  extend = function() {
    var args, i, ret;
    args = Array.prototype.slice.apply(arguments);
    ret = args[0];
    if (args.length >= 2) {
      i = 1;
      while (i < args.length) {
        extend2.call(this, ret, args[i]);
        i++;
      }
    }
    return ret;
  };
  options = extend({}, paginatorDefaults, env.config.paginator, tagDefaults, env.config.tag);
  tagHomePages = {};
  allTags = [];
  getTagHome = function(tag) {
    return tagHomePages[tag];
  };
  getAllTags = function() {
    return allTags;
  };
  getTagsFromArticle = function(article) {
    if (article.metadata.tags) {
      return article.metadata.tags.split(/,\s*/);
    } else {
      return [];
    }
  };
  getArticles = function(contents) {
    if (contents[options.articles]) {
      return contents[options.articles]._.directories.map(function(item) {
        return item.index;
      });
    } else {
      return [];
    }
  };
  processTags = function(contents) {
    var articles, tags;
    tags = {};
    articles = getArticles(contents);
    articles.forEach(function(article) {
      return getTagsFromArticle(article).forEach(function(tag) {
        return tags[tag] = tag;
      });
    });
    return allTags = Object.keys(tags);
  };
  getArticlesByTag = function(contents, tagName) {
    var articles;
    articles = getArticles(contents);
    articles.sort(function(a, b) {
      return b.date - a.date;
    });
    return articles.filter(function(a) {
      return a.metadata.tags && a.metadata.tags.split(/,\s*/).indexOf(tagName) > -1;
    });
  };
  TagPaginatorPage = (function(_super) {
    __extends(TagPaginatorPage, _super);


    /* Based on the PaginatorPage class */

    function TagPaginatorPage(tagName, pageNum, articles) {
      this.tagName = tagName;
      this.pageNum = pageNum;
      this.articles = articles;
    }

    TagPaginatorPage.prototype.getFilename = function() {
      return options.filename.replace('%d', this.pageNum).replace('%s', this.tagName);
    };

    TagPaginatorPage.prototype.getView = function() {
      return function(env, locals, contents, templates, callback) {
        var ctx, template;
        template = templates[options.template];
        if (template == null) {
          return callback(new Error("unknown paginator template '" + options.template + "'"));
        }
        ctx = {
          articles: this.articles,
          prevPage: this.prevPage,
          nextPage: this.nextPage,
          tagName: this.tagName
        };
        env.utils.extend(ctx, locals);
        return template.render(ctx, callback);
      };
    };

    return TagPaginatorPage;

  })(env.plugins.Page);
  env.registerGenerator('tagPaginator', function(contents, callback) {
    var rv, tags;
    tags = processTags(contents);
    rv = {
      pages: {}
    };
    tags.forEach(function(tag) {
      var articles, i, numPages, page, pageArticles, pages, _i, _j, _k, _len, _len1;
      articles = getArticlesByTag(contents, tag);
      numPages = Math.ceil(articles.length / options.perPage);
      pages = [];
      for (i = _i = 0; 0 <= numPages ? _i < numPages : _i > numPages; i = 0 <= numPages ? ++_i : --_i) {
        pageArticles = articles.slice(i * options.perPage, (i + 1) * options.perPage);
        pages.push(new TagPaginatorPage(tag, i + 1, pageArticles));
      }
      for (i = _j = 0, _len = pages.length; _j < _len; i = ++_j) {
        page = pages[i];
        page.prevPage = pages[i - 1];
        page.nextPage = pages[i + 1];
      }
      for (_k = 0, _len1 = pages.length; _k < _len1; _k++) {
        page = pages[_k];
        rv.pages["" + (tag + '-' + page.pageNum) + ".page"] = page;
      }
      return tagHomePages[tag] = pages[0];
    });
    return callback(null, rv);
  });
  env.helpers.getArticlesByTag = getArticlesByTag;
  env.helpers.getAllTags = getAllTags;
  env.helpers.getTagHome = getTagHome;
  env.helpers.getTagsFromArticle = getTagsFromArticle;
  return callback();
};
